https://ipads.se.sjtu.edu.cn/courses/compilers/labs/lab5.html

将lab4/tiger.lex和lab4/tiger.y复制到lab5。需要修改frame.h、x86frame.c、semant.[ch]、translate.[ch]完成中间代码生成。

semant模块在lab4的基础上进行扩充，在类型检查正确后调用translate模块构造中间代码树。其中与机器相关的部分由translate模块调用frame模块获得。

修正了lab4在判断类型是否匹配时的bug（具体参见lab4/note.txt），添加了 break语句必须在循环内 的验证。

lab5的测试脚本相当简单，只是简单地测试fragment（包括函数和字符串两种）的个数是否正确，而不管fragment的内容如何（并且lab5的Tiger样例程序都是正确的，因此不用处理报错信息）。如果只为了通过lab5的测试，统计一下函数和字符串的个数即可……

书的第6章和第7章给出了详细的解释和部分C代码；上课的PPT给出了F_frame_结构体的实现；之前为lab2/3提供的final_tiger给出了所有的头文件作为参考(特别是translate.h)。

======================================================

对几个概念的理解：

1、栈帧：由于最终目标是生成x86汇编，这里只考虑x86的栈帧结构。
在x86通常的调用约定中，寄存器ebp保存帧指针，访问栈帧内的变量通过相对帧指针（而不是栈指针）的偏移量寻址。ebp指向的内存保存调用者的帧指针，ebp+4指向的内存保存返回地址
-传入的参数：从被调用者的角度看，参数的地址从偏移量ebp+8开始向高地址扩展。
-栈上的临时变量：偏移量从ebp-4开始向低地址扩展。
-传出的参数：不在栈帧中保留这部分空间，而是在每次call之前push对应的参数。
在x86frame.c中，F_frame结构的构造函数处理了传入的参数，之后每一次调用F_allocLocal(F_frame f, bool escape)，如果escape为true，则在栈上分配一个临时变量；如果为false，则分配一个临时寄存器（Temp_temp）（在这里假设寄存器无穷多，由后面lab的寄存器分配过程进一步处理）；然后记录到F_frame结构中。

2、静态链（static link）：
在嵌套定义的函数中，为了访问上层函数的局部变量，书上提到了静态链（static link）、嵌套层次显示表（display）、λ提升（lambda lifting）三种方式（6.1节最后）。这里采用静态链方式。
当一个函数f被调用时，将静态包含f的函数的帧指针作为第一个参数传递给f。这样ebp+8指向静态链，函数原本的参数从ebp+12开始向高地址扩展。
例如，当一个函数调用直接定义在其内部的函数时，将调用者的帧指针（ebp的值）作为静态链传递给被调用者；当递归调用自身或同一层次的其他函数时，将调用者的静态链（ebp+8处的内存值，也是静态包含调用者的函数的帧指针）作为被调用者的静态链；当调用更外层的函数时，逐层向外展开以获得静态链（[...[[[ebp+8]+8]+8]...+8]，[]表示取内存中的值，[]的个数为 函数调用表达式 的层次和 被调用函数 的层次之差）
（注意，在semant.c的实现上，当transDec遇到函数定义（A_functionDec）时，函数以当前的level放入E_FunEntry表中，而处理函数体的时候创建一个更低的层次new_level调用transExp，即 函数体的层次总是比函数定义的层次低一层，才能保证静态链的访存次数（[]的个数）正好等于 函数调用表达式的层次 与 被调用函数定义 的层次之差）（如果先创建新的层次，并用新的层次放入E_FunEntry表和调用transExp，即 函数体的层次与函数定义的层次相同，静态链的计算会稍微复杂一点）

3、semant.c中transVar、transExp、transDec的Temp_label类型参数，表示的是直接包含break语句的循环的done标号（书的7.2节，while循环部分）。（lab4没有实现 break语句必须在循环内部 这个检查，lab5通过label参数完成了）

4、struct Cx和T_exp的转换：
Cx实质是跳转标号未确定的T_cjump语句（T_cjump属于T_stm），对应6种比较运算（=、<>、>、<、>=、<=）表达式（Tr_relOpExp）。
在翻译if语句（if(cond) then thene else elsee）和while语句（while(cond) body）时，对cond施加unCx，然后填充跳转标号，得到一个T_cjump语句。如果cond是比较运算（如，if(a<>0)），则unCx不涉及转换；否则（如，if(a)），则unCx需要把T_exp转换为Cx。
比较运算是有值的，当需要使用值的时候（如，a:=(b<c)，根据b、c的大小关系，a取值为0或1），unEx需要把Cx转换为T_exp

======================================================

Tiger语言的规范定义了字符串的6种比较运算（=、<>、>、<、>=、<=），但这里只实现了相等（=）和不相等（<>）两种。

（书第6章最后的 程序设计 提到了FindEscape模块，这个模块最终在lab6中被实现（其实可以提前到lab5中））


至此，Tiger编译器的 前端部分 完成
