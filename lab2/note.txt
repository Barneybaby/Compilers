https://ipads.se.sjtu.edu.cn/courses/compilers/labs/lab2.html

这是实现整个编译器的第一步，词法分析。需要完成tiger.lex文件。
词法分析过程以字节为单位读取源文件，解析出词法单元。
每次调用词法分析器，返回一个整数作为词法单元的标识。

书上给出了tiger语言的词法单词。大部分都可以直接识别，需要注意的是字符串和嵌套注释


嵌套注释：
lex初始处于INITIAL状态，当遇到"/*"时进入COMMENT状态。在COMMENT状态下，遇到"/*"对计数器加1,遇到"*/"对计数器减1。计数器归零后回到INITIAL状态。


字符串：
tiger语言的字符串支持多种转义字符，包括：（以下摘抄自书）
\n          换行符
\t          制表符Tab
\^c         控制字符c
\ddd        具有ASCII码ddd（3个十进制数字）的单个字符
\"          双引号字符（"）
\\          反斜线字符（\）
\f___f\     此序列将被忽略，其中f___f代表一个或多个以上的格式化字符
           （非可打印字符的子集，至少应包含空白符、制表符、换行符、走纸符）
            组成的序列。（这允许在一行的末尾和下一行的开头各写一个“\”，
            从而写出一个长度超过一行的长字符串）
在lab2中，只实现了\n和\t两种转义，其他情况只是简单地忽略“\”字符（这间接实现了\"和\\）。遇到换行也将自动结束字符串。
具体实现上，当lex遇到双引号（\x22）的时候，调用一个自定义函数逐个字符读取并处理转义，返回识别后的字符串。
（也可以直接编写正则表达式识别出字符串后再处理转义，但这个正则表达式比较复杂，可读性和调试都比较困难，而且仍需要单独处理转义，故未采用此方法）
（至于通过正则表达式一次性识别字符串和转义……直接放弃了此方法）


====================


注意lab2中对长度为0的字符串返回NULL指针而不是空字符串，这只是为了同时通过lab2测试和final test。在lab3及以后，这里返回的是空字符串而非空指针
测试时发现的另一个问题：C语言printf函数对NULL参数的处理：
程序一：
#include <stdio.h>
int main() {
    printf("%s\n", NULL);  // ----------> 产生segmentation fault
    return 0;
}
程序二：
#include <stdio.h>
int main() {
    printf("%s", NULL);  // -----> 打印出(NULL)
    return 0;
}
程序三：
#include <stdio.h>
int main() {
    puts(NULL);  // ----------> 产生segmentation fault
    return 0;
}
（以上是在linux平台，gcc 5.4.0 使用 -O0 参数编译运行的结果）
第一种情况下printf被优化为了puts（尽管用-O0指定了不优化……），但第二中情况没有（可以通过反汇编验证）
printf对NULL参数会打印出(NULL)（这应该是未定义行为），但puts遇到NULL参数会直接错误
objdump -d 反汇编的结果对程序一和程序三完全相同


======================


特别注意，tiger语言允许“\0”作为合法的字符串的一部分，而C语言把“\0”作为字符串的结束符。如果词法分析只是简单的返回指向字符串开头的指针，在后面的编译阶段会丢失“\0”后面的字符串内容（这个bug直到最后生成汇编程序时才发现……）
对词法分析器的完善参见lab6，添加了对\ddd转义的处理（这样字符串就可以包含任何字符）和对“\0”的特殊处理

lab2提供了final test，用以检验词法分析器能否通过最终的测试。后续lab将要完成的内容在这里以.o文件的形式提供。
将tiger.lex复制到final_tiger文件夹下（需要先回滚到final_tiger的初始提交状态，因为lab3修改了final_tiger），然后make;./gradeMe.sh
